package shodan

import (
	"context"
	"io"
	"net/http"
	"net/url"
)

type (
	// ExploitSource is the name of the data source.
	ExploitSource string

	// ExploitPlatform is the target platform type.
	ExploitPlatform string

	// ExploitType is the type of exploit.
	ExploitType string
)

const (
	exploitSearchPath = "/search"
	exploitCountPath  = "/count"

	// ExploitSourceCVE is "CVE".
	ExploitSourceCVE ExploitSource = "CVE"

	// ExploitSourceMetasploit is "Metasploit".
	ExploitSourceMetasploit ExploitSource = "Metasploit"

	// ExploitSourceExploitDB is "ExploitDB".
	ExploitSourceExploitDB ExploitSource = "ExploitDB"

	// ExploitTypeDOS is "dos".
	ExploitTypeDOS ExploitType = "dos"

	// ExploitTypeExploit is "exploit".
	ExploitTypeExploit ExploitType = "exploit"

	// ExploitTypeLocal is "local".
	ExploitTypeLocal ExploitType = "local"

	// ExploitTypeRemote is "remote".
	ExploitTypeRemote ExploitType = "remote"

	// ExploitTypeShellcode is "shellcode".
	ExploitTypeShellcode ExploitType = "shellcode"

	// ExploitTypeWebapps is "webapps".
	ExploitTypeWebapps ExploitType = "webapps"

	// ExploitPlatformAix is "aix".
	ExploitPlatformAix ExploitPlatform = "aix"

	// ExploitPlatformCGI is "cgi".
	ExploitPlatformCGI ExploitPlatform = "cgi"

	// ExploitPlatformFreeBSD is "freebsd".
	ExploitPlatformFreeBSD ExploitPlatform = "freebsd"

	// ExploitPlatformHardware is "hardware".
	ExploitPlatformHardware ExploitPlatform = "hardware"

	// ExploitPlatformJava is "Java".
	ExploitPlatformJava ExploitPlatform = "Java"

	// ExploitPlatformJSP is "jsp".
	ExploitPlatformJSP ExploitPlatform = "jsp"

	// ExploitPlatformLin86 is "lin_x86".
	ExploitPlatformLin86 ExploitPlatform = "lin_x86"

	// ExploitPlatformLinux is "Linux".
	ExploitPlatformLinux ExploitPlatform = "Linux"

	// ExploitPlatformMultiple is "multiple".
	ExploitPlatformMultiple ExploitPlatform = "multiple"

	// ExploitPlatformNovell is "novell".
	ExploitPlatformNovell ExploitPlatform = "novell"

	// ExploitPlatformOSX is "osx".
	ExploitPlatformOSX ExploitPlatform = "osx"

	// ExploitPlatformPHP is "PHP".
	ExploitPlatformPHP ExploitPlatform = "PHP"

	// ExploitPlatformTrue64 is "true64".
	ExploitPlatformTrue64 ExploitPlatform = "true64"

	// ExploitPlatformUnix is "Unix".
	ExploitPlatformUnix ExploitPlatform = "Unix"

	// ExploitPlatformWindows is "Windows".
	ExploitPlatformWindows ExploitPlatform = "Windows"
)

// Exploit represents the normalized data from a variety of vulnerability data sources.
type Exploit struct {
	// Unique ID for the exploit/ vulnerability (integer or string)
	ID interface{} `json:"_id"`

	// An array of Bugtraq IDs that reference this vulnerability
	BID []int `json:"bid"`

	// An array of relevant CVE IDs that reference this exploit
	CVE []string `json:"cve"`

	// An array of Microsoft Security Bulletin reference IDs for this exploit
	MSB []string `json:"msb"`

	// An array (integer or string) of OSVDB IDs that are relevant to this exploit
	OSVDB []interface{} `json:"osvdb"`

	// A description explaining the details of the exploit
	Description string `json:"description"`

	// The name of the data source
	Source ExploitSource `json:"source"`

	// The author of the exploit/vulnerability
	Author interface{} `json:"author"`

	// The actual code for the exploit
	Code string `json:"code"`

	// The timestamp for when the exploit was released in the UTC timezone. Example: "2014-01-15T05:49:56.283713"
	Date string `json:"date"`

	// An array of platforms or a single platform that the exploit targets
	Platform interface{} `json:"platform"`

	// The port number for the affected service
	Port int `json:"port"`

	// The type of exploit
	Type ExploitType `json:"type"`

	// Is Privileged?
	Privileged bool `json:"privileged"`

	// Rank, i.e. "excellent"
	Rank string `json:"rank"`

	// Version
	Version string `json:"version"`
}

// ExploitSearchOptions is options for exploit search query.
type ExploitSearchOptions struct {
	// Search query used to search the database of known exploits
	Query string `url:"query"`

	// A comma-separated list of properties to get summary information on
	Facets string `url:"facets,omitempty"`

	// The page number to page through results 100 at a time. It is ignored in CountExploits method
	Page int `url:"page,omitempty"`
}

// ExploitSearch is exploit search results.
type ExploitSearch struct {
	Matches []*Exploit          `json:"matches"`
	Facets  map[string][]*Facet `json:"facets"`
	Total   int                 `json:"total"`
}

// NewExploitRequest prepares new request to exploit shodan api.
func (c *Client) NewExploitRequest(
	method string,
	path string,
	params interface{},
	body io.Reader,
) (*http.Request, error) {
	u, err := url.Parse(c.ExploitBaseURL + path)
	if err != nil {
		return nil, err
	}

	return c.newRequest(method, u, params, body)
}

// SearchExploits searches across a variety of data sources for exploits and
// use facets to get summary information.
func (c *Client) SearchExploits(ctx context.Context, options *ExploitSearchOptions) (*ExploitSearch, error) {
	if options == nil || options.Query == "" {
		return nil, ErrInvalidQuery
	}

	req, err := c.NewExploitRequest("GET", exploitSearchPath, options, nil)
	if err != nil {
		return nil, err
	}

	var found ExploitSearch
	if err := c.Do(ctx, req, &found); err != nil {
		return nil, err
	}

	return &found, nil
}

// CountExploits behaves identical to the "/search" method with the difference
// that it doesn't return any results.
func (c *Client) CountExploits(ctx context.Context, options *ExploitSearchOptions) (*ExploitSearch, error) {
	if options == nil || options.Query == "" {
		return nil, ErrInvalidQuery
	}

	req, err := c.NewExploitRequest("GET", exploitCountPath, options, nil)
	if err != nil {
		return nil, err
	}

	var found ExploitSearch
	if err := c.Do(ctx, req, &found); err != nil {
		return nil, err
	}

	return &found, nil
}
